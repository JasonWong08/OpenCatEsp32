<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Petoi Web Coding Blocks</title>
  <!-- 1. 首先加载 Blockly 核心文件 -->
  <script src="./node_modules/blockly/blockly_compressed.js"></script>
  <script src="./node_modules/blockly/blocks_compressed.js"></script>
  <script src="./node_modules/blockly/javascript_compressed.js"></script>
  <!-- 2. 语言文件改为动态加载 -->
  <!-- <script src="./node_modules/blockly/msg/zh-hans.js"></script> -->
  <!-- <script src="./node_modules/blockly/msg/en.js"></script> -->
  <!-- 3. 加载自定义翻译 -->
  <script src="./lang/translations.js"></script>
  <!-- 4. 然后加载自定义积木块文件 -->
  <script src="./blocks/communication.js"></script>
  <script src="./blocks/generators.js"></script>
  <!-- 5. 加载 WebSocket 客户端 -->
  <script src="./js/petoi_async_client.js"></script>
  <script src="./js/toolbox.js"></script>
  <link rel="stylesheet" href="./styles.css">
</head>

<body>
  <div class="header">
    <div class="title" data-i18n="appTitle">Petoi Web Coding Blocks</div>
    <div class="language-switch">
      <button id="zhBtn" class="lang-btn" onclick="setLanguage('zh')">中文</button>
      <button id="enBtn" class="lang-btn active" onclick="setLanguage('en')">English</button>
      <button id="jaBtn" class="lang-btn" onclick="setLanguage('ja')">日本語</button>
    </div>
  </div>
  <div class="container">
    <div class="button-group">
      <button onclick="showCode()" data-i18n="showCode">Show Code</button>
      <button onclick="runCode()" data-i18n="runCode">Run Code</button>
      <button onclick="saveWorkspace()" data-i18n="saveProgram">Save Program</button>
      <button onclick="document.getElementById('loadInput').click()" data-i18n="loadProgram">Load Program</button>
      <button onclick="triggerSkillFileUpload()" data-i18n="uploadSkills">Upload Skills</button>
      <input type="file" id="skillFileInput" accept=".md" multiple onchange="handleSkillFilesUpload(this.files)"
        style="display: none;">
      <button onclick="clearWorkspace()" data-i18n="clearAll">Clear All</button>
      <input type="file" id="loadInput" accept=".json" onchange="loadWorkspace(this.files[0])">
      <span id="currentFileLabel" data-i18n="currentFileLabel" style="margin-left: 10px; color: #555;"></span>
      <span id="currentFileName" style="color: #555; font-style: italic;"></span>
      <div class="right-aligned-container">
        <button onclick="quickConnect()" id="quickConnectBtn" data-i18n="quickConnect">Quick Connect</button>
      </div>
    </div>

    <div class="workspace-container">
      <div id="blocklyDiv"></div>
      <div class="resizer" id="divider"></div>
      <div class="windows-container">
        <div id="skillFilesContainer"
          style="display: none; margin-bottom: 10px; padding: 10px; background-color: #f5f5f5; border-radius: 4px;">
          <h4 style="margin: 0 0 10px 0;" data-i18n="uploadedSkills">Uploaded Skills</h4>
          <div id="skillFilesList" style="max-height: 150px; overflow-y: auto;"></div>
        </div>
        <div id="consoleWindow">
          <div class="area-header">
            <span class="area-title" data-i18n="consoleLog">Console Log</span>
            <div class="button-group">
              <button id="showTimestampBtn" onclick="toggleShowTimestamp()" class="toggle-button active"
                data-i18n="showTimestamp">Timestamp</button>
              <button id="showSentCommandsBtn" onclick="toggleShowSentCommands()" class="toggle-button"
                data-i18n="showSentCommands">Show Commands</button>
              <button onclick="clearConsole()" class="clear-button" data-i18n="clearLog">Clear Log</button>
            </div>
          </div>
          <div id="consoleLog" class="dark-scrollbar"></div>
        </div>
        <!-- 添加水平分隔线，用于调整控制台和串口区域的高度比例 -->
        <div class="horizontal-resizer" id="console-serial-divider"></div>
        <!-- 添加串口通信相关的HTML结构 -->
        <div id="serialContainer">
          <div class="area-header">
            <span class="area-title" id="serialOutputTitle" data-i18n="serialOutput">Serial Monitor</span>
            <div class="button-group">
              <button onclick="openSerialPort()" class="serial-button" id="openSerialBtn"
                data-i18n="serialConnect">Connect Serial Port</button>
              <button id="showSerialTimestampBtn" onclick="toggleShowSerialTimestamp()" class="toggle-button active"
                style="display: none;" data-i18n="showTimestamp">Timestamp</button>
              <button onclick="closeSerialPort()" class="clear-button" id="closeSerialBtn" style="display: none;"
                data-i18n="closeSerial">Close Connection</button>
              <button onclick="clearSerialOutput()" class="clear-button" id="clearSerialBtn" style="display: none;"
                data-i18n="clearLog">Clear Log</button>
            </div>
          </div>
          <div id="serialInterface" style="display: none;">
            <div class="serial-output dark-scrollbar" id="serialOutput"></div>
            <div class="serial-input-container">
              <input type="text" id="serialInput" placeholder="Enter content to send"
                data-i18n="serialInputPlaceholder">
              <button onclick="sendSerialData()" class="serial-button" data-i18n="send">Send</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 自定义主题
    // 将函数设为全局可用
    window.PetoiAsyncClient = PetoiAsyncClient;

    // 初始化变量
    var workspace;

    // 当前语言
    let isChangingLanguage = false;
    // save entry block ids
    let startBlockIds = [];

    // 新增翻译助手函数
    function getText(key)
    {
      return TRANSLATIONS[currentLang][key] || key;
    }

    // 获取格式化的时间戳 [HH:MM:SS.mmm]
    function getFormattedTimestamp()
    {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      const milliseconds = String(now.getMilliseconds()).padStart(3, '0');
      return `[${hours}:${minutes}:${seconds}.${milliseconds}]`;
    }

    // 更新自定义积木的定义
    function updateCustomBlockDefinitions()
    {
      // 更新所有工作区中的积木
      if (workspace)
      {
        // 使用根块优先的方式处理
        // 1. 首先找出所有没有父块的根积木
        const rootBlocks = workspace.getTopBlocks(true);

        // 2. 递归处理每个根积木及其子积木
        rootBlocks.forEach(rootBlock =>
        {
          updateBlockAndChildren(rootBlock);
        });
      }

      // 定义递归更新块和其子块的函数
      function updateBlockAndChildren(block)
      {
        if (block.type === 'make_connection' ||
          block.type === 'get_digital_input' ||
          block.type === 'get_analog_input' ||
          block.type === 'get_sensor_input' ||
          block.type === 'set_digital_output' ||
          block.type === 'set_analog_output' ||
          block.type === 'send_custom_command' ||
          block.type === 'delay_ms' ||
          block.type === 'posture' ||
          block.type === 'gait' ||
          block.type === 'acrobatic_moves' ||
          block.type === 'set_motor_angle' ||
          block.type === 'get_joint_angle' ||
          block.type === 'get_all_joint_angles' ||
          block.type === 'gyro_control' ||
          block.type === 'console_log_variable')
        {
          // 保存原有字段值
          const fieldValues = {};
          for (let i = 0; i < block.inputList.length; i++)
          {
            const input = block.inputList[i];
            for (let j = 0; j < input.fieldRow.length; j++)
            {
              const field = input.fieldRow[j];
              if (field.name)
              {
                fieldValues[field.name] = field.getValue();
              }
            }
          }

          // 保存位置信息
          const position = block.getRelativeToSurfaceXY();

          // 保存连接信息 - 包括所有输入连接
          const savedConnections = [];

          // 保存下一个块的连接
          if (block.nextConnection && block.nextConnection.isConnected())
          {
            savedConnections.push({
              type: 'next',
              connection: block.nextConnection.targetConnection
            });
          }

          // 保存所有输入连接
          for (let i = 0; i < block.inputList.length; i++)
          {
            const input = block.inputList[i];
            if (input.connection && input.connection.isConnected())
            {
              savedConnections.push({
                type: 'input',
                name: input.name,
                connection: input.connection.targetConnection
              });
            }
          }

          // 清空输入列表，避免积木元素堆叠
          block.inputList = [];

          // 重新初始化积木
          const initFunc = Blockly.Blocks[block.type].init;
          if (initFunc)
          {
            initFunc.call(block);

            // 恢复字段值
            for (const name in fieldValues)
            {
              const field = block.getField(name);
              if (field)
              {
                field.setValue(fieldValues[name]);
              }
            }

            // 恢复位置 - 只对根块有效
            if (!block.getParent())
            {
              const newPosition = block.getRelativeToSurfaceXY();
              block.moveBy(position.x - newPosition.x, position.y - newPosition.y);
            }

            // 重新渲染以确保视觉正确
            block.initSvg();
            block.render();
          }

          // 延迟恢复连接，确保所有块都已更新
          setTimeout(() =>
          {
            // 恢复所有保存的连接
            savedConnections.forEach(savedConn =>
            {
              if (savedConn.type === 'next')
              {
                if (block.nextConnection && savedConn.connection)
                {
                  block.nextConnection.connect(savedConn.connection);
                }
              } else if (savedConn.type === 'input')
              {
                const input = block.getInput(savedConn.name);
                if (input && input.connection && savedConn.connection)
                {
                  input.connection.connect(savedConn.connection);
                }
              }
            });
          }, 0);
        }

        // 递归处理所有子块
        if (block.nextConnection && block.nextConnection.targetBlock())
        {
          updateBlockAndChildren(block.nextConnection.targetBlock());
        }

        // 处理所有输入连接的子块
        for (let i = 0; i < block.inputList.length; i++)
        {
          const input = block.inputList[i];
          if (input.connection && input.connection.targetBlock())
          {
            updateBlockAndChildren(input.connection.targetBlock());
          }
        }
      }
    }

    // 保存当前工作区的积木
    function saveCurrentWorkspace()
    {
      return Blockly.serialization.workspaces.save(workspace);
    }

    // 恢复工作区积木
    function restoreWorkspace(state)
    {
      Blockly.serialization.workspaces.load(state, workspace);
    }

    function initWorkspace()
    {
      // 创建新的工具箱配置，确保使用新语言
      blocklyGlobalConfig();
      const newToolbox = createToolbox();
      workspace = Blockly.inject('blocklyDiv', {
        media: './node_modules/blockly/media/',
        toolbox: newToolbox,
        theme: customTheme,
        grid: {
          spacing: 20,
          length: 3,
          colour: '#ccc',
          snap: true
        },
        zoom: {
          controls: true,
          wheel: true,
          startScale: 1.0,
          maxScale: 3,
          minScale: 0.3,
          scaleSpeed: 1.2
        },
        trashcan: true
      });

      // 监听工作区变化事件
      workspace.addChangeListener(handleWorkspaceEvent);
    }

    // 切换语言
    function setLanguage(lang)
    {
      if (isChangingLanguage || currentLang === lang) return;
      isChangingLanguage = true;

      // 更新按钮样式
      document.getElementById('zhBtn').classList.toggle('active', lang === 'zh');
      document.getElementById('enBtn').classList.toggle('active', lang === 'en');
      document.getElementById('jaBtn').classList.toggle('active', lang === 'ja');

      // 保存当前工作区状态
      const workspaceState = saveCurrentWorkspace();

      // 加载相应语言文件
      loadLanguageFile(lang, function ()
      {
        // 设置当前语言
        currentLang = lang;

        // 重新注入工作区
        workspace.dispose();

        initWorkspace();

        // 恢复工作区状态
        restoreWorkspace(workspaceState);

        // 再次更新自定义积木
        updateCustomBlockDefinitions();

        // 更新撤销和重做按钮状态
        updateUndoRedoState();

        // 更新UI文本
        updateUITranslations();

        isChangingLanguage = false;
      });
    }

    // 初始化时设置默认语言为英文
    window.addEventListener('DOMContentLoaded', function ()
    {
      // 确保先动态加载英文语言文件，再进行其他初始化
      loadLanguageFile('en', function ()
      {
        // 设置当前语言为英文
        currentLang = 'en';

        initWorkspace();

        // 初始化自定义积木
        updateCustomBlockDefinitions();

        // 更新UI文本
        updateUIText();

        if (typeof window.updateUITranslations === 'function')
        {
          window.updateUITranslations();
        }

        // 添加窗口大小变化事件监听器
        window.addEventListener('resize', resizeBlocklyWorkspace);

        // 设置初始宽度比例
        const container = document.querySelector('.workspace-container');
        const blocklyDiv = document.getElementById('blocklyDiv');
        const windowsContainer = document.querySelector('.windows-container');

        blocklyDiv.style.flexBasis = '70%';
        blocklyDiv.style.width = '70%';
        windowsContainer.style.flexBasis = '29%'; // 减去分隔线宽度
        windowsContainer.style.width = '29%';

        // 初始调整工作区大小
        resizeBlocklyWorkspace();
        // 添加撤销和重做按钮
        addUndoRedoButtons();
        resetWorkspace();

        // 更新按钮状态
        document.getElementById('zhBtn').classList.toggle('active', false);
        document.getElementById('enBtn').classList.toggle('active', true);
        document.getElementById('jaBtn').classList.toggle('active', false);
      });

      // 添加控制台和串口输出区域的键盘复制功能
      function setupCopyKeyboardShortcuts()
      {
        // 控制台区域复制功能
        const consoleLogElement = document.getElementById('consoleLog');
        // 设置tabindex，使元素可以接收键盘事件
        consoleLogElement.setAttribute('tabindex', '0');

        consoleLogElement.addEventListener('keydown', function (e)
        {
          // 检测Ctrl+C或Command+C (Mac)
          if ((e.ctrlKey || e.metaKey) && e.key === 'c')
          {
            const selectedText = window.getSelection().toString();
            if (selectedText)
            {
              navigator.clipboard.writeText(selectedText)
                .then(() => {/* 移除复制成功消息 */ })
                .catch(err => console.error(getText("copyFailed"), err));
            }
          }
        });

        // 使控制台区域可以通过点击获得焦点
        consoleLogElement.addEventListener('click', function ()
        {
          this.focus();
        });

        // 串口输出区域复制功能
        const serialOutputElement = document.getElementById('serialOutput');
        // 设置tabindex，使元素可以接收键盘事件
        serialOutputElement.setAttribute('tabindex', '0');

        serialOutputElement.addEventListener('keydown', function (e)
        {
          // 检测Ctrl+C或Command+C (Mac)
          if ((e.ctrlKey || e.metaKey) && e.key === 'c')
          {
            const selectedText = window.getSelection().toString();
            if (selectedText)
            {
              navigator.clipboard.writeText(selectedText)
                .then(() => {/* 移除复制成功消息 */ })
                .catch(err => console.error(getText("copyFailed"), err));
            }
          }
        });

        // 使串口输出区域可以通过点击获得焦点
        serialOutputElement.addEventListener('click', function ()
        {
          this.focus();
        });
      }

      // 初始化复制功能
      setupCopyKeyboardShortcuts();

      // 移除旧的checkbox事件监听器，现在使用按钮点击事件
    });

    function handleWorkspaceEvent(event)
    {
      // console.log('workspace event', event);
      // 当工作区被清空时，添加默认积木块
      if (event.type === Blockly.Events.FINISHED_LOADING)
      {
        resetWorkspace();
      }

      // 更新撤销和重做按钮状态
      updateUndoRedoState();
    }
    // 添加动态加载语言文件的辅助函数
    function loadLanguageFile(lang, callback)
    {
      const script = document.createElement('script');
      script.onload = function ()
      {
        if (typeof callback === 'function')
        {
          callback();
        }
      };

      // 根据语言选择对应的Blockly语言文件
      const langMap = {
        'zh': './node_modules/blockly/msg/zh-hans.js',
        'en': './node_modules/blockly/msg/en.js',
        'ja': './node_modules/blockly/msg/ja.js'
        // 可以在这里添加更多语言
      };
      script.src = langMap[lang] || langMap['en']; // 默认使用英文

      // 标记并添加新脚本
      script.setAttribute('data-language-script', 'true');
      document.head.appendChild(script);
    }

    // 更新UI文本的函数
    function updateUIText()
    {
      // 调用translations.js中的updateUITranslations函数
      if (typeof window.updateUITranslations === 'function')
      {
        window.updateUITranslations();
      }

      // 更新当前文件名显示
      const currentFileNameSpan = document.getElementById('currentFileName');
      const currentFileLabelSpan = document.getElementById('currentFileLabel');

      if (currentFileLabelSpan)
      {
        // 只在有文件时显示标签
        currentFileLabelSpan.style.display = currentFile ? 'inline' : 'none';
      }

      if (currentFileNameSpan && currentFile)
      {
        currentFileNameSpan.textContent = currentFile.name;
      } else if (currentFileNameSpan)
      {
        currentFileNameSpan.textContent = '';
      }

      // 如果串口已连接，更新串口监视器标题以保持端口信息
      if (port)
      {
        const serialTitle = document.getElementById('serialOutputTitle');
        if (serialTitle)
        {
          const displayName = getSerialPortDisplayName(port);
          serialTitle.textContent = getText("serialMonitorTitle").replace("{portName}", displayName);
        }
      }

      // 更新timestamp按钮的翻译文本
      const timestampBtn = document.getElementById('showTimestampBtn');
      const serialTimestampBtn = document.getElementById('showSerialTimestampBtn');
      if (timestampBtn)
      {
        timestampBtn.textContent = getText("showTimestamp");
      }
      if (serialTimestampBtn)
      {
        serialTimestampBtn.textContent = getText("showTimestamp");
      }
    }

    // 窗口大小变化时调整Blockly工作区
    function resizeBlocklyWorkspace()
    {
      // 在下一个事件循环中执行，确保DOM已更新
      setTimeout(function ()
      {
        if (workspace)
        {
          // 确保工作区和控制台区域的宽度比例保持不变
          const container = document.querySelector('.workspace-container');
          const blocklyDiv = document.getElementById('blocklyDiv');
          const windowsContainer = document.querySelector('.windows-container');

          // 如果没有显式设置宽度，则应用默认比例
          if (!blocklyDiv.style.width || !windowsContainer.style.width)
          {
            const containerWidth = container.getBoundingClientRect().width;
            blocklyDiv.style.flexBasis = '70%';
            blocklyDiv.style.width = '70%';
            windowsContainer.style.flexBasis = '29%'; // 减去分隔线宽度
            windowsContainer.style.width = '29%';
          }

          Blockly.svgResize(workspace);

          // 在调整工作区大小后重新定位撤销重做按钮
          repositionUndoRedoButtons();
        }
      }, 0);
    }

    // 定位撤销重做按钮的函数
    function repositionUndoRedoButtons()
    {
      const undoRedoControls = document.querySelector('.undoRedoControls');
      if (!undoRedoControls) return;

      // 获取放大缩小按钮容器
      const zoomControls = document.querySelector('.blocklyZoom');

      if (zoomControls)
      {
        const zoomRect = zoomControls.getBoundingClientRect();

        // 将撤销重做按钮与缩放控件在同一条竖线上
        undoRedoControls.style.right = (window.innerWidth - zoomRect.right) + 'px'; // 与放大缩小按钮右对齐
        undoRedoControls.style.top = (zoomRect.top - 70) + 'px'; // 放在放大缩小按钮上方
      }
    }

    // 添加默认的connect with IP积木块
    function addDefaultConnectionBlock()
    {
      // 只有当工作区不存在startBlockId时才添加默认积木
      if (startBlockIds.length == 0)
      {
        // 创建make_connection积木块
        const connectionBlock = workspace.newBlock('make_connection');
        // 设置IP地址为当前设备IP
        connectionBlock.setFieldValue(currentDeviceIP, 'IP_ADDRESS');
        // 初始化积木块(确保所有连接点正确设置)
        connectionBlock.initSvg();
        // 渲染积木块
        connectionBlock.render();
        // 将积木块移动到合适的位置
        connectionBlock.moveBy(50, 50);

        // init gyro_control block, set gyro_control block to disable, connect gyro_control block to connection block
        const gyroControlBlock = workspace.newBlock('gyro_control');
        gyroControlBlock.setFieldValue("0", 'STATE');
        gyroControlBlock.initSvg();
        gyroControlBlock.render();
        gyroControlBlock.moveBy(50, 50);
        connectionBlock.nextConnection.connect(gyroControlBlock.previousConnection);
        connectionBlock.setDeletable(false);
        gyroControlBlock.setDeletable(false);
        workspace.clearUndo();
        startBlockIds.push(connectionBlock.id);
        startBlockIds.push(gyroControlBlock.id);
      }
    }

    // 添加清空工作区的函数
    function clearWorkspace()
    {
      //delete all blocks except make_connection and gyro_control
      const blocksToDelete = workspace.getAllBlocks().filter(block => !startBlockIds.includes(block.id));
      blocksToDelete.forEach(block =>
      {
        try
        {
          block.dispose();
        } catch (e)
        {
        }
      });
      updateUndoRedoState();
    }

    function resetWorkspace()
    {
      addDefaultConnectionBlock();
      // workspace.clearUndo();
      updateUndoRedoState();
    }

    function showCode()
    {
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;

      // 修改：查找工作区中的'make_connection'积木块（Connect with IP）
      const makeConnectionBlocks = workspace.getBlocksByType('make_connection');

      // 如果没有找到make_connection积木块，显示错误信息
      if (makeConnectionBlocks.length === 0)
      {
        console.error(getText("noConnectionBlockError") || "错误：请添加一个'Connect with IP'积木块并将代码连接在其下方！");
        alert(getText("noConnectionBlockError") || "错误：请添加一个'Connect with IP'积木块并将代码连接在其下方！");
        return;
      }

      // 如果找到多个make_connection积木块，使用第一个
      const mainBlock = makeConnectionBlocks[0];

      // 准备一个临时的工作区，只包含我们要运行的代码
      const tempWorkspace = new Blockly.Workspace();

      // 复制主块及其所有连接的块到临时工作区
      // 先克隆主块
      const clonedMainBlock = Blockly.serialization.blocks.save(mainBlock);
      Blockly.serialization.blocks.append(clonedMainBlock, tempWorkspace);

      // 生成临时工作区的代码
      var code = Blockly.JavaScript.workspaceToCode(tempWorkspace);

      // 清理临时工作区
      tempWorkspace.dispose();

      // 创建蒙版背景
      var overlay = document.createElement('div');
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      overlay.style.zIndex = '1200';  // 提高z-index值，高于控件
      overlay.style.display = 'flex';
      overlay.style.justifyContent = 'center';
      overlay.style.alignItems = 'center';

      // 点击蒙版时关闭对话框
      overlay.addEventListener('click', function (event)
      {
        if (event.target === overlay)
        {
          document.body.removeChild(overlay);
        }
      });

      // 创建一个包含代码的对话框
      var codeDialog = document.createElement('div');
      codeDialog.className = 'code-dialog';
      codeDialog.style.position = 'relative';
      codeDialog.style.backgroundColor = '#282c34';
      codeDialog.style.color = '#abb2bf';
      codeDialog.style.padding = '20px';
      codeDialog.style.borderRadius = '8px';
      codeDialog.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.5)';
      codeDialog.style.zIndex = '1201';  // 比overlay高1
      codeDialog.style.maxWidth = '90%';
      codeDialog.style.maxHeight = '80%';
      codeDialog.style.overflow = 'auto';
      codeDialog.style.fontFamily = '"Consolas", "Monaco", "Microsoft YaHei", "PingFang SC", "SimHei", sans-serif';

      // 标题
      var titleBar = document.createElement('div');
      titleBar.style.display = 'flex';
      titleBar.style.justifyContent = 'space-between';
      titleBar.style.alignItems = 'center';
      titleBar.style.marginBottom = '15px';

      var title = document.createElement('h3');
      // 使用getText函数获取翻译文本
      title.innerHTML = getText("generatedJSCode");
      title.style.margin = '0';
      title.style.color = '#e6e6e6';
      title.style.fontFamily = '"Microsoft YaHei", "PingFang SC", "SimHei", "Arial", sans-serif';

      var closeButton = document.createElement('button');
      closeButton.textContent = '×';
      closeButton.style.background = 'none';
      closeButton.style.border = 'none';
      closeButton.style.color = '#e6e6e6';
      closeButton.style.fontSize = '24px';
      closeButton.style.cursor = 'pointer';
      closeButton.onclick = function ()
      {
        document.body.removeChild(overlay);
      };

      titleBar.appendChild(title);
      titleBar.appendChild(closeButton);
      codeDialog.appendChild(titleBar);

      // 格式化代码
      // 1. 分割每行
      var codeLines = code.split('\n');

      // 2. 创建代码显示区域
      var codeContainer = document.createElement('pre');
      codeContainer.style.margin = '0';
      codeContainer.style.overflow = 'auto';
      codeContainer.style.backgroundColor = '#282c34';
      codeContainer.style.padding = '10px';
      codeContainer.style.borderRadius = '4px';
      codeContainer.style.lineHeight = '1.5';
      codeContainer.style.maxHeight = '60vh';
      codeContainer.style.fontSize = '14px';
      codeContainer.style.color = '#e6e6e6'; // 设置代码文本颜色

      // 添加自定义滚动条样式
      codeContainer.style.scrollbarWidth = 'thin';
      codeContainer.style.scrollbarColor = '#4d4d4d #282c34';

      // 添加整个代码块的文本，而不是逐行添加
      codeContainer.textContent = code;

      codeDialog.appendChild(codeContainer);

      // 添加复制按钮
      var copyButton = document.createElement('button');
      copyButton.innerHTML = getText("copyCode");
      copyButton.style.marginTop = '15px';
      copyButton.style.padding = '6px 12px';
      copyButton.style.backgroundColor = '#4d78cc';
      copyButton.style.color = 'white';
      copyButton.style.border = 'none';
      copyButton.style.borderRadius = '4px';
      copyButton.style.cursor = 'pointer';
      copyButton.style.fontFamily = '"Microsoft YaHei", "PingFang SC", "SimHei", "Arial", sans-serif';
      copyButton.onclick = function ()
      {
        navigator.clipboard.writeText(code).then(function ()
        {
          copyButton.innerHTML = getText("copySuccess");
          setTimeout(function ()
          {
            copyButton.innerHTML = getText("copyCode");
          }, 2000);
        });
      };

      codeDialog.appendChild(copyButton);
      overlay.appendChild(codeDialog);
      document.body.appendChild(overlay);

      // 添加ESC键监听
      function handleEscKey(event)
      {
        if (event.key === 'Escape')
        {
          document.body.removeChild(overlay);
          document.removeEventListener('keydown', handleEscKey);
        }
      }
      document.addEventListener('keydown', handleEscKey);
    }

    function runCode()
    {
      window.LoopTrap = 1000;
      Blockly.JavaScript.INFINITE_LOOP_TRAP =
        'if (--window.LoopTrap < 0) throw "无限循环";\n';

      // 查找工作区中的'make_connection'积木块（Connect with IP）
      const makeConnectionBlocks = workspace.getBlocksByType('make_connection');

      if (makeConnectionBlocks.length === 0)
      {
        console.error(getText("noConnectionBlockError") || "错误：请添加一个'Connect with IP'积木块并将代码连接在其下方！");
        alert(getText("noConnectionBlockError") || "错误：请添加一个'Connect with IP'积木块并将代码连接在其下方！");
        return;
      }

      const mainBlock = makeConnectionBlocks[0];
      const tempWorkspace = new Blockly.Workspace();
      const clonedMainBlock = Blockly.serialization.blocks.save(mainBlock);
      Blockly.serialization.blocks.append(clonedMainBlock, tempWorkspace);
      var code = Blockly.JavaScript.workspaceToCode(tempWorkspace);
      tempWorkspace.dispose();
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;

      // 替换所有 console.log 为 asyncLog
      code = code.replace(/console\.log\((.*?)\);/g, 'await asyncLog($1);');

      // 包装整个代码到一个异步函数中
      const runCodeBlock = `
function asyncLog(message) {
  return new Promise((resolve) => {
    console.log(message);
    setTimeout(resolve, 0);
  });
}

(async function () {

${code}

  try {
    // 程序结束时自动发送休息指令'd'
    await asyncLog(getText("programEndingRestCommand"));
    await webRequest("d", 5000, true);
  } catch (e) {
    console.error(getText("restCommandFailed") + e.message);
  }
  await closeConnection();
  console.log(getText("taskEnded"));
})().catch((e) => {
  console.error(getText("networkRequestError") + ": " + e.message);
  alert(getText("networkRequestError") + ": " + e.message);
});
`
      try
      {
        eval(runCodeBlock);
      } catch (e)
      {
        console.info("code:");
        console.info(runCodeBlock);
        console.error(getText("networkRequestError") + ": " + e.message);
        alert(getText("networkRequestError") + ": " + e.message);
      }
    }

    function saveWorkspace()
    {
      // 显示保存对话框，提供保存和另存为选项
      promptSaveOptions();
    }

    function promptSaveOptions()
    {
      // 创建蒙版背景
      var overlay = document.createElement('div');
      overlay.className = 'overlay';

      // 创建对话框
      var dialog = document.createElement('div');
      dialog.className = 'wifi-dialog';
      dialog.style.maxWidth = '400px';

      // 使用getText获取本地化文本
      const title = getText('saveProgram');
      const message = currentFile ?
        getText('currentFile').replace('{filename}', currentFile.name) :
        getText('noFileSaved');
      const saveText = getText('save');
      const saveAsText = getText('saveAs');
      const cancelText = getText('cancel');
      const warningText = getText('saveWarning');

      dialog.innerHTML = `
        <h3>${title}</h3>
        <p>${message}</p>
        <p style="color: #999; font-size: 12px;">${warningText}</p>
      <div style="text-align: center; margin: 20px 0;">
        ${currentFile ?
          `<button onclick="saveFile('${currentFile.name}'); closeSaveOptionsDialog();" class="confirm" style="margin-right: 10px;">
              ${saveText}
            </button>` : ''}
        <button onclick="saveFileWithPrompt(); closeSaveOptionsDialog();" class="confirm" style="margin-right: 10px;">
          ${saveAsText}
        </button>
        <button onclick="closeSaveOptionsDialog()" class="cancel">
          ${cancelText}
        </button>
      </div>
    `;

      document.body.appendChild(overlay);
      document.body.appendChild(dialog);
    }

    function closeSaveOptionsDialog()
    {
      const dialog = document.querySelector('.wifi-dialog');
      const overlay = document.querySelector('.overlay');
      if (dialog) dialog.remove();
      if (overlay) overlay.remove();
    }

    function saveFile(filename)
    {
      // 创建工作区状态对象
      let workspaceState = Blockly.serialization.workspaces.save(workspace);
      workspaceState.skills = window.uploadedSkills;
      workspaceState.startBlockIds = startBlockIds; // 保存startBlockIds

      const blob = new Blob([JSON.stringify(workspaceState, null, 2)], { type: 'application/json' });

      let a = document.createElement('a');
      a.download = filename;
      a.href = URL.createObjectURL(blob);
      a.click();

      // 显示保存成功消息
      showSaveSuccessDialog(filename);
    }

    function saveFileWithPrompt()
    {
      // 显示默认文件名
      let defaultName = 'program.json';
      if (currentFile)
      {
        defaultName = currentFile.name;
      }

      // 提示用户输入文件名
      const fileName = prompt(
        getText("enterFileName"),
        defaultName
      );

      if (fileName)
      {
        // 添加.json扩展名（如果用户没有输入）
        let finalName = fileName;
        if (!finalName.toLowerCase().endsWith('.json'))
        {
          finalName += '.json';
        }

        // 保存文件
        saveFile(finalName);

        // 更新当前文件名
        currentFile = {
          name: finalName,
          lastModified: new Date().getTime()
        };

        // 更新显示的文件名和标签
        updateUIText();
      }
    }

    function showSaveSuccessDialog(fileName)
    {
      // 创建蒙版背景
      var overlay = document.createElement('div');
      overlay.className = 'overlay';

      // 创建对话框
      var dialog = document.createElement('div');
      dialog.className = 'wifi-dialog';
      dialog.style.maxWidth = '450px';

      // 使用getText函数获取本地化文本
      const title = getText("saveSuccess");
      const message = getText("savedToDownloads");
      const fileNameNote = getText("filenameNote").replace("{filename}", fileName);
      const closeText = getText("close");

      dialog.innerHTML = `
      <h3 style="color: #4CAF50;">${title}</h3>
      <p>${message}</p>
      <p style="margin-top: 10px; font-size: 14px;">${fileNameNote}</p>
      <div style="text-align: center; margin: 20px 0;">
        <button onclick="closeSuccessDialog()" class="confirm">
          ${closeText}
        </button>
      </div>
    `;

      document.body.appendChild(overlay);
      document.body.appendChild(dialog);
    }

    function closeSuccessDialog()
    {
      const dialog = document.querySelector('.wifi-dialog');
      const overlay = document.querySelector('.overlay');
      if (dialog) dialog.remove();
      if (overlay) overlay.remove();
    }

    // 存储上传的技能文件
    window.uploadedSkills = [];

    function triggerSkillFileUpload()
    {
      const skillFileInput = document.getElementById('skillFileInput');
      skillFileInput.value = null;
      skillFileInput.click();
    }

    // 处理技能文件上传
    function handleSkillFilesUpload(files)
    {
      if (!files || files.length === 0) return;

      let successCount = 0;
      let failCount = 0;
      let processedCount = 0;

      for (let i = 0; i < files.length; i++)
      {
        const file = files[i];
        handleSkillFileUpload(file, (success) =>
        {
          if (success)
          {
            successCount++;
          } else
          {
            failCount++;
          }
          processedCount++;

          // 当所有文件都处理完成后，显示统计信息
          if (processedCount === files.length)
          {
            if (successCount > 0)
            {
              console.info([getText("skillFilesUploaded").replace("{count}", successCount)]);
            }
            if (failCount > 0)
            {
              console.error([getText("skillFilesUploadFailed").replace("{count}", failCount)]);
            }
          }
        });
      }
    }

    // 处理单个技能文件上传
    function handleSkillFileUpload(file, callback)
    {
      if (!file)
      {
        if (callback) callback(false);
        return;
      }

      const reader = new FileReader();
      reader.onload = function (e)
      {
        try
        {
          // 解析技能文件内容
          const skillData = parseSkillFile(e.target.result);

          // 存储解析后的数据,如果文件名已存在，则覆盖
          const existingSkill = uploadedSkills.find(skill => skill.name === file.name);
          if (existingSkill)
          {
            existingSkill.content = skillData;
          } else
          {
            uploadedSkills.push({
              name: file.name,
              content: skillData
            });
          }

          // 更新文件列表显示
          updateSkillFilesList();

          // 显示成功消息
          console.info([getText("skillFileUploaded").replace("{filename}", file.name)]);

          if (callback) callback(true);
        } catch (err)
        {
          console.error([getText("skillFilesUploadFailed").replace("{filename}", file.name)]);
          if (callback) callback(false);
        }
      };
      reader.readAsText(file);
    }

    // 解析技能文件内容
    function parseSkillFile(content)
    {
      // 移除所有空行和注释
      const lines = content.split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('//'));

      // 查找token行
      const tokenLine = lines.find(line => line.startsWith('# Token'));
      if (!tokenLine)
      {
        throw new Error('未找到Token');
      }
      const token = lines[lines.indexOf(tokenLine) + 1].trim();

      // 查找data数组
      const dataStartIndex = lines.findIndex(line => line.startsWith('# Data'));
      if (dataStartIndex === -1)
      {
        throw new Error('未找到Data');
      }

      // 解析data数组
      const dataLines = lines.slice(dataStartIndex + 1);
      let data = [];

      for (const line of dataLines)
      {
        // 跳过空行和注释
        if (!line || line.startsWith('#')) continue;

        // 移除行首尾的大括号和空格
        const cleanLine = line.replace(/[{}]/g, '').trim();
        if (!cleanLine) continue;

        // 分割数字并转换为整数
        const numbers = cleanLine.split(',')
          .map(num => parseInt(num.trim()))
          .filter(num => !isNaN(num));

        if (numbers.length > 0)
        {
          data.push(numbers);
        }
      }

      return {
        token: token,
        data: data
      };
    }

    // 更新技能文件列表显示
    function updateSkillFilesList()
    {
      const container = document.getElementById('skillFilesContainer');
      const list = document.getElementById('skillFilesList');

      if (uploadedSkills.length === 0)
      {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';
      list.innerHTML = '';

      uploadedSkills.forEach((skill, index) =>
      {
        const item = document.createElement('div');
        item.style.padding = '5px';
        item.style.borderBottom = '1px solid #ddd';
        item.style.display = 'flex';
        item.style.justifyContent = 'space-between';
        item.style.alignItems = 'center';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = skill.name;
        nameSpan.style.cursor = 'pointer';
        nameSpan.onclick = () => loadSkill(skill);

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.style.background = 'none';
        deleteBtn.style.border = 'none';
        deleteBtn.style.color = '#ff4444';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.fontSize = '20px';
        deleteBtn.style.padding = '0 5px';
        deleteBtn.onclick = (e) =>
        {
          e.stopPropagation();
          uploadedSkills.splice(index, 1);
          updateSkillFilesList();
        };

        item.appendChild(nameSpan);
        item.appendChild(deleteBtn);
        list.appendChild(item);
      });
    }

    // 加载技能文件
    function loadSkill(skill)
    {
      try
      {
        // 将解析后的数据转换为字符串并发送到串口
        if (writer)
        {
          const skillString = JSON.stringify(skill.content);
          writer.write(new TextEncoder().encode(skillString + '\n'));
          addConsoleMessage([getText("skillLoaded").replace("{filename}", skill.name)]);
        } else
        {
          addConsoleMessage([getText("serialNotConnected")]);
        }
      } catch (err)
      {
        console.error(getText("loadSkillFailed"), err);
        addConsoleMessage([getText("skillLoadFailed")]);
      }
    }

    function loadWorkspace(file)
    {
      var reader = new FileReader();
      reader.onload = function (e)
      {
        try
        {
          var saveData = JSON.parse(e.target.result);

          // 加载工作区
          Blockly.serialization.workspaces.load(saveData, workspace);

          // 加载技能文件
          if (saveData.skills && Array.isArray(saveData.skills))
          {
            window.uploadedSkills = saveData.skills;
            updateSkillFilesList();
          }

          // 恢复startBlockIds
          if (saveData.startBlockIds && Array.isArray(saveData.startBlockIds))
          {
            startBlockIds = saveData.startBlockIds;
            // 验证保存的startBlockIds是否仍然存在于工作区中
            const existingBlocks = startBlockIds.filter(id => workspace.getBlockById(id));
            if (existingBlocks.length !== startBlockIds.length)
            {
              // 如果有些块不存在了，重新初始化
              startBlockIds = [];
              addDefaultConnectionBlock();
            }
          } else
          {
            // 如果没有保存的startBlockIds，重新初始化
            startBlockIds = [];
            addDefaultConnectionBlock();
          }

          // 保存当前文件信息
          currentFile = file;

          // 更新文件名和标签显示
          updateUIText();

          if (currentDeviceIP !== "192.168.4.1")
          {
            // 查找工作区中的make_connection积木块并更新IP地址
            const makeConnectionBlocks = workspace.getBlocksByType('make_connection');
            if (makeConnectionBlocks && makeConnectionBlocks.length > 0)
            {
              // 更新第一个make_connection积木块的IP_ADDRESS字段
              makeConnectionBlocks[0].setFieldValue(currentDeviceIP, 'IP_ADDRESS');
            }
          }

          // 不使用alert，而是在控制台显示加载成功信息
          const successMsg = getText('fileLoaded').replace('{filename}', file.name);
          addConsoleMessage([successMsg]);
        } catch (err)
        {
          console.error(getText("loadFileFailed"), err);
          alert(getText('loadFileFailed'));
        }
      };
      reader.readAsText(file);
    }

    document.addEventListener('keydown', function (event)
    {
      if ((event.ctrlKey || event.metaKey) && event.key === 's')
      {
        event.preventDefault();
        saveWorkspace();
      }
      if ((event.ctrlKey || event.metaKey) && event.key === 'o')
      {
        event.preventDefault();
        document.getElementById('loadInput').click();
      }
      // 添加撤销快捷键(Ctrl+Z)
      if ((event.ctrlKey || event.metaKey) && !event.shiftKey && event.key === 'z')
      {
        //prevent browser default behavior
        event.preventDefault();
      }
      // 添加重做快捷键(Ctrl+Y 或 Ctrl+Shift+Z)
      if ((event.ctrlKey || event.metaKey) &&
        ((!event.shiftKey && event.key.toLowerCase() === 'y') ||
          (event.shiftKey && event.key === 'z')))
      {
        event.preventDefault();
        // 使用redoStack_属性检查是否可以重做
        if (workspace.redoStack_ && workspace.redoStack_.length > 0)
        {
          workspace.undo(true);
          updateUndoRedoState();
        }
      }
    });

    function addConsoleMessage(args)
    {
      const logDiv = document.getElementById('consoleLog');
      const showTimestamp = document.getElementById('showTimestampBtn').classList.contains('active');
      const time = getFormattedTimestamp();

      const messageDiv = document.createElement('div');
      messageDiv.className = 'console-item';

      // 处理不同类型的参数
      const messages = Array.from(args).map(arg =>
      {
        if (typeof arg === 'object')
        {
          try
          {
            return JSON.stringify(arg, null, 2);
          } catch (e)
          {
            return String(arg);
          }
        }
        return String(arg);
      });

      const messageText = messages.join(' ');

      // 创建时间戳容器
      const timestampSpan = document.createElement('span');
      timestampSpan.className = 'timestamp';
      timestampSpan.textContent = `${time} `;
      timestampSpan.style.display = showTimestamp ? 'inline' : 'none';

      // 创建消息内容容器
      const messageSpan = document.createElement('span');
      messageSpan.className = 'message-content';
      messageSpan.textContent = `${messageText} `;

      // 将两个容器添加到消息div中
      messageDiv.appendChild(timestampSpan);
      messageDiv.appendChild(messageSpan);

      // 检测是否为"任务结束"消息，如果是则使用绿色字体
      if (messageText === getText('taskEnded'))
      {
        messageDiv.style.color = '#4CAF50'; // 使用绿色
        messageDiv.style.fontWeight = 'bold'; // 加粗显示
      }

      // 使用原生DOM方法确保立即渲染，改为添加到末尾
      logDiv.appendChild(messageDiv);

      // 保持最多显示100条记录
      while (logDiv.children.length > 100)
      {
        logDiv.removeChild(logDiv.firstChild);
      }

      // 立即滚动到底部，不使用setTimeout
      logDiv.scrollTop = logDiv.scrollHeight;

      // 强制DOM重绘，确保视图更新
      void logDiv.offsetHeight;
    }

    function clearConsole()
    {
      document.getElementById('consoleLog').innerHTML = '';
    }

    // 切换是否显示时间戳
    function toggleShowTimestamp()
    {
      const showTimestamp = !document.getElementById('showTimestampBtn').classList.contains('active');
      const btn = document.getElementById('showTimestampBtn');
      const consoleLog = document.getElementById('consoleLog');

      if (showTimestamp)
      {
        btn.classList.add('active');
      } else
      {
        btn.classList.remove('active');
      }

      // 获取所有时间戳容器并切换显示状态
      const timestampSpans = consoleLog.querySelectorAll('.timestamp');
      timestampSpans.forEach(span =>
      {
        span.style.display = showTimestamp ? 'inline' : 'none';
      });
    }

    // 切换是否显示串口时间戳
    function toggleShowSerialTimestamp()
    {
      const showSerialTimestamp = !document.getElementById('showSerialTimestampBtn').classList.contains('active');
      const btn = document.getElementById('showSerialTimestampBtn');
      const serialOutput = document.getElementById('serialOutput');

      if (showSerialTimestamp)
      {
        btn.classList.add('active');
      } else
      {
        btn.classList.remove('active');
      }

      // 获取所有时间戳容器并切换显示状态
      const timestampSpans = serialOutput.querySelectorAll('.timestamp');
      timestampSpans.forEach(span =>
      {
        span.style.display = showSerialTimestamp ? 'inline' : 'none';
      });
    }

    // 切换是否显示发送的命令
    function toggleShowSentCommands()
    {
      showSentCommands = !showSentCommands;
      // 更新按钮样式
      const btn = document.getElementById('showSentCommandsBtn');
      if (showSentCommands)
      {
        btn.classList.add('active');
      } else
      {
        btn.classList.remove('active');
      }
    }

    // 只重写 console.log
    const originalLog = console.log;
    console.log = function ()
    {
      addConsoleMessage(arguments);
      originalLog.apply(console, arguments);
    };

    // 添加串口通信相关的JavaScript代码
    let port = null;
    let reader = null;
    let writer = null;

    // 添加文件相关变量
    let currentFile = null;
    let currentFilePath = '';

    // 设备IP地址
    let currentDeviceIP = '192.168.4.1'; // 默认IP地址

    // 添加命令历史记录相关变量
    let commandHistory = [];
    let historyIndex = -1;
    let tempInputValue = '';

    // 是否显示发送的命令
    let showSentCommands = false;

    let ipCheckTimer = null;
    let lastPartialIP = null;
    let serialBufferText = '';
    let serialBuffer = '';
    let lastSerialMessageTime = 0; // 记录上次收到串口消息的时间
    let serialOutputBuffer = ''; // 串口输出缓冲区
    let serialOutputTimer = null; // 串口输出处理定时器

    // ESP32开发板使用的USB串口芯片配置
    const ESP32_USB_CHIPS = [
      { vendorId: 0x1a86, productId: 0x7523, name: 'CH340' },  // CH340
      { vendorId: 0x1a86, productId: 0x55d4, name: 'CH343' },  // CH343
      { vendorId: 0x10c4, productId: 0xea60, name: 'CP2102' }, // CP2102
      { vendorId: 0x10c4, productId: 0xea61, name: 'CP2102' }, // CP2102 (某些变种)
      { vendorId: 0x1a86, productId: 0x5523, name: 'CH340' },  // CH340 (某些变种)
    ];

    // 系统检测函数
    function detectOperatingSystem()
    {
      const userAgent = navigator.userAgent;
      const platform = navigator.platform;

      if (userAgent.includes('Chrome OS') || userAgent.includes('CrOS'))
      {
        return 'chromebook';
      } else if (platform.includes('Mac'))
      {
        return 'mac';
      } else if (platform.includes('Win'))
      {
        return 'windows';
      } else if (platform.includes('Linux'))
      {
        return 'linux';
      } else
      {
        return 'unknown';
      }
    }

    // 检查串口是否为ESP32开发板使用的芯片
    function isESP32SerialPort(port)
    {
      try
      {
        const portInfo = port.getInfo();
        if (!portInfo.usbVendorId || !portInfo.usbProductId)
        {
          return false;
        }

        return ESP32_USB_CHIPS.some(chip =>
          chip.vendorId === portInfo.usbVendorId &&
          chip.productId === portInfo.usbProductId
        );
      } catch (error)
      {
        console.warn(getText("cannotGetPortInfo"), error);
        return false;
      }
    }

    // 获取串口显示名称（Arduino IDE风格）
    function getSerialPortDisplayName(port)
    {
      try
      {
        const portInfo = port.getInfo();
        const os = detectOperatingSystem();

        if (os === 'mac')
        {
          // macOS: 生成类似 cu.wchusbserial58CF0756201 的格式
          const vendorId = portInfo.usbVendorId?.toString(16).toUpperCase() || '0000';
          const productId = portInfo.usbProductId?.toString(16).toUpperCase() || '0000';

          // 根据不同的芯片生成不同的前缀
          if (portInfo.usbVendorId === 0x1a86)
          {
            // CH340/CH343
            return `cu.wchusbserial${vendorId}${productId}`;
          } else if (portInfo.usbVendorId === 0x10c4)
          {
            // CP2102
            return `cu.SLAB_USBtoUART`;
          } else
          {
            // 其他USB串口
            return `cu.usbserial${vendorId}${productId}`;
          }
        } else if (os === 'linux')
        {
          // Linux: 类似格式
          const vendorId = portInfo.usbVendorId?.toString(16).toUpperCase() || '0000';
          const productId = portInfo.usbProductId?.toString(16).toUpperCase() || '0000';
          return `ttyUSB${vendorId}${productId}`;
        } else if (os === 'windows')
        {
          // Windows: 显示芯片名称
          const chip = ESP32_USB_CHIPS.find(chip =>
            chip.vendorId === portInfo.usbVendorId &&
            chip.productId === portInfo.usbProductId
          );
          return chip ? chip.name : 'USB Serial';
        } else
        {
          // 其他系统
          const vendorId = portInfo.usbVendorId?.toString(16).toUpperCase() || '0000';
          const productId = portInfo.usbProductId?.toString(16).toUpperCase() || '0000';
          return `Serial${vendorId}${productId}`;
        }
      } catch (error)
      {
        console.warn(getText("cannotGetPortDisplayName"), error);
        return 'Serial Port';
      }
    }

    // 获取ESP32串口显示名称（保留用于ESP32特定功能）
    function getESP32PortDisplayName(port)
    {
      try
      {
        const portInfo = port.getInfo();
        const chip = ESP32_USB_CHIPS.find(chip =>
          chip.vendorId === portInfo.usbVendorId &&
          chip.productId === portInfo.usbProductId
        );

        const os = detectOperatingSystem();
        let displayName = '';

        if (chip)
        {
          // 如果是ESP32芯片
          if (os === 'windows')
          {
            displayName = `${chip.name} ESP32`;
          } else if (os === 'mac' || os === 'linux')
          {
            displayName = `${chip.name} (ESP32)`;
          } else
          {
            displayName = `${chip.name} ESP32`;
          }
        } else
        {
          // 如果不是ESP32芯片，显示USB信息
          const vendorId = portInfo.usbVendorId?.toString(16) || 'unknown';
          const productId = portInfo.usbProductId?.toString(16) || 'unknown';
          displayName = `USB Serial (0x${vendorId}:0x${productId})`;
        }

        return displayName;
      } catch (error)
      {
        console.warn(getText("cannotGetPortDisplayName"), error);
        return 'Unknown Serial Port';
      }
    }

    // 获取并过滤ESP32串口
    async function getESP32SerialPorts()
    {
      try
      {
        // 获取所有已授权的串口
        const ports = await navigator.serial.getPorts();

        // 过滤出ESP32串口
        const esp32Ports = ports.filter(port => isESP32SerialPort(port));

        console.log(getText("foundESP32Ports").replace("{count}", esp32Ports.length));
        return esp32Ports;
      } catch (error)
      {
        console.error(getText("getPortListFailed"), error);
        return [];
      }
    }

    // 创建ESP32串口选择对话框
    function createESP32PortSelector(ports)
    {
      return new Promise((resolve, reject) =>
      {
        // 创建遮罩层
        const overlay = document.createElement('div');
        overlay.className = 'esp32-port-selector';

        // 创建对话框
        const dialog = document.createElement('div');
        dialog.className = 'esp32-port-dialog';

        dialog.innerHTML = `
          <h3 style="margin: 0 0 15px 0; color: #333;">${getText("selectESP32Port")}</h3>
          <div style="margin-bottom: 15px;">
            ${ports.map((port, index) =>
        {
          const displayName = getESP32PortDisplayName(port);
          return `
                <div class="esp32-port-option" onclick="selectESP32Port(${index})">
                  <strong>${displayName}</strong>
                </div>
              `;
        }).join('')}
          </div>
          <div class="esp32-port-buttons">
            <button class="cancel" onclick="cancelESP32PortSelection()">${getText("cancel")}</button>
          </div>
        `;

        // 添加选择函数到全局作用域
        window.selectESP32Port = (index) =>
        {
          const selectedPort = ports[index];
          document.body.removeChild(overlay);
          delete window.selectESP32Port;
          delete window.cancelESP32PortSelection;
          resolve(selectedPort);
        };

        window.cancelESP32PortSelection = () =>
        {
          document.body.removeChild(overlay);
          delete window.selectESP32Port;
          delete window.cancelESP32PortSelection;
          reject(new Error(getText("userCancelledSelection")));
        };

        document.body.appendChild(overlay);
      });
    }

    // 创建所有串口选择对话框
    function createAllPortsSelector(ports)
    {
      return new Promise((resolve, reject) =>
      {
        // 创建遮罩层
        const overlay = document.createElement('div');
        overlay.className = 'esp32-port-selector';

        // 创建对话框
        const dialog = document.createElement('div');
        dialog.className = 'esp32-port-dialog';

        dialog.innerHTML = `
          <h3 style="margin: 0 0 15px 0; color: #333;">${getText("selectSerialPort")}</h3>
          <div style="margin-bottom: 15px;">
            ${ports.map((port, index) =>
        {
          const displayName = getSerialPortDisplayName(port);
          return `
                <div class="esp32-port-option" onclick="selectAllPort(${index})">
                  <strong>${displayName}</strong>
                </div>
              `;
        }).join('')}
          </div>
          <div class="esp32-port-buttons">
            <button class="cancel" onclick="cancelAllPortSelection()">${getText("cancel")}</button>
          </div>
        `;

        // 添加选择函数到全局作用域
        window.selectAllPort = (index) =>
        {
          const selectedPort = ports[index];
          document.body.removeChild(overlay);
          delete window.selectAllPort;
          delete window.cancelAllPortSelection;
          resolve(selectedPort);
        };

        window.cancelAllPortSelection = () =>
        {
          document.body.removeChild(overlay);
          delete window.selectAllPort;
          delete window.cancelAllPortSelection;
          reject(new Error(getText("userCancelledSelection")));
        };

        // 将对话框添加到遮罩层中
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
      });
    }

    async function openSerialPort()
    {
      try
      {
        // 检测操作系统
        const os = detectOperatingSystem();
        console.log(getText("detectedOS").replace("{os}", os));

        // 获取所有已授权的串口
        const allPorts = await navigator.serial.getPorts();
        console.log(getText("foundAuthorizedPorts").replace("{count}", allPorts.length));

        // 显示所有串口的简要信息
        allPorts.forEach((port, index) =>
        {
          try
          {
            const displayName = getSerialPortDisplayName(port);
            console.log(getText("portInfo").replace("{index}", index + 1).replace("{name}", displayName));
          } catch (error)
          {
            console.log(getText("portInfoError").replace("{index}", index + 1));
          }
        });

        // 获取ESP32串口列表
        const esp32Ports = allPorts.filter(port => isESP32SerialPort(port));

        if (esp32Ports.length === 0)
        {
          // 如果没有找到ESP32串口，检查所有可用串口
          console.log(getText("showingAllPorts"));

          if (allPorts.length === 0)
          {
            // 如果没有任何已授权的串口，请求用户选择新的串口
            console.log(getText("noAuthorizedPorts"));
            const selectPort = await navigator.serial.requestPort();
            port = selectPort;
          } else if (allPorts.length === 1)
          {
            // 如果只有一个串口，自动连接
            console.log(getText("foundOnePort"));
            port = allPorts[0];
          } else
          {
            // 显示所有可用串口的选择对话框
            console.log(getText("showingPortsForSelection").replace("{count}", allPorts.length));
            port = await createAllPortsSelector(allPorts);
          }
        } else if (esp32Ports.length === 1)
        {
          // 如果只有一个ESP32串口，直接使用
          console.log(getText("foundOneESP32Port"));
          port = esp32Ports[0];
        } else
        {
          // 如果有多个ESP32串口，显示选择对话框
          console.log(getText("foundMultipleESP32Ports").replace("{count}", esp32Ports.length));
          port = await createESP32PortSelector(esp32Ports);
        }

        // 连接串口
        try
        {
          await port.open({ baudRate: 115200 });
          console.log(getText("esp32PortConnected"));
        } catch (portError)
        {
          // 检查是否是因为串口被占用
          if (portError.name === 'NetworkError' ||
            portError.message.includes('failed to open') ||
            portError.message.includes('busy') ||
            portError.message.includes('in use'))
          {
            // 显示提示窗口
            alert(getText("serialPortBusy"));
            return;
          } else
          {
            // 其他错误，继续抛出
            throw portError;
          }
        }

        // 显示串口界面，使用flex布局但不改变整体宽度
        const serialInterface = document.getElementById('serialInterface');
        serialInterface.style.display = 'flex';

        // 添加connected类，调整串口容器样式
        const serialContainer = document.getElementById('serialContainer');
        serialContainer.classList.add('connected');

        // 显示分隔线
        document.getElementById('console-serial-divider').style.display = 'block';

        // 设置控制台和串口区域的初始高度比例为50%/50%
        document.getElementById('consoleWindow').style.flex = '50';
        serialContainer.style.flex = '49'; // 减去分隔线高度

        // 更新按钮状态
        document.getElementById('openSerialBtn').style.display = 'none'; // 隐藏连接按钮
        document.getElementById('showSerialTimestampBtn').style.display = 'inline-flex'; // 显示时间戳按钮
        document.getElementById('closeSerialBtn').style.display = 'inline-flex'; // 显示关闭按钮
        document.getElementById('clearSerialBtn').style.display = 'inline-flex'; // 显示清除按钮

        // 更新串口标题显示连接的设备信息
        const serialTitle = document.getElementById('serialOutputTitle');
        if (serialTitle)
        {
          const displayName = getSerialPortDisplayName(port);
          serialTitle.textContent = getText("serialMonitorTitle").replace("{portName}", displayName);
        }

        // 强制重新调整工作区大小，确保布局不变
        // 等DOM更新后再执行调整
        setTimeout(function ()
        {
          // 确保工作区和串口区域的宽度比例保持不变
          const container = document.querySelector('.workspace-container');
          const blocklyDiv = document.getElementById('blocklyDiv');
          const windowsContainer = document.querySelector('.windows-container');

          // 重新应用之前的宽度比例
          if (blocklyDiv.style.width)
          {
            const blocklyWidth = blocklyDiv.style.width;
            blocklyDiv.style.flexBasis = blocklyWidth;
            blocklyDiv.style.width = blocklyWidth;

            // 确保窗口容器宽度正确
            const blocklyPercent = parseFloat(blocklyWidth);
            windowsContainer.style.flexBasis = `${99 - blocklyPercent}% `;
            windowsContainer.style.width = `${99 - blocklyPercent}% `;
          }

          resizeBlocklyWorkspace();
          repositionUndoRedoButtons();
        }, 100);

        // 设置读取器
        reader = port.readable.getReader();
        readSerialData();

        // 设置写入器
        writer = port.writable.getWriter();

        // 连接成功后自动发送'w'指令获取IP地址
        await sendWifiCommand();

      } catch (error)
      {
        console.error(getText("serialConnectionError"), error);
        // 连接失败时重置按钮样式
        resetQuickConnectButton();
      }
    }

    async function closeSerialPort()
    {
      try
      {
        if (reader)
        {
          await reader.cancel();
          reader = null;
        }
        if (writer)
        {
          await writer.close();
          writer = null;
        }
        if (port)
        {
          await port.close();
          port = null;
        }

        // 更新UI状态
        document.getElementById('serialInterface').style.display = 'none';

        // 移除connected类，恢复串口容器默认样式
        const serialContainer = document.getElementById('serialContainer');
        serialContainer.classList.remove('connected');

        // 调整控制台和串口区域的比例，控制台占据大部分空间
        document.getElementById('consoleWindow').style.flex = '90';
        serialContainer.style.flex = '10';

        // 隐藏分隔线
        document.getElementById('console-serial-divider').style.display = 'none';
        document.getElementById('openSerialBtn').style.display = 'inline-flex'; // 显示连接按钮
        document.getElementById('showSerialTimestampBtn').style.display = 'none'; // 隐藏时间戳按钮
        document.getElementById('closeSerialBtn').style.display = 'none'; // 隐藏关闭按钮
        document.getElementById('clearSerialBtn').style.display = 'none'; // 隐藏清除按钮

        // 重置串口监视器标题
        const serialTitle = document.getElementById('serialOutputTitle');
        if (serialTitle)
        {
          serialTitle.textContent = getText("serialOutput");
        }

        // 重置Quick Connect按钮样式
        resetQuickConnectButton();

        // 强制重新调整工作区大小
        setTimeout(function ()
        {
          resizeBlocklyWorkspace();
          repositionUndoRedoButtons();
        }, 100);

        // 不要重置当前IP地址，保留上一次的连接信息
        // currentDeviceIP = '192.168.4.1'; // 重置为默认IP
      } catch (error)
      {
        console.error(getText("closeSerialError"), error);
      }
    }

    async function quickConnect()
    {
      // 检查串口是否已连接
      if (!port)
      {
        // 如果串口未连接，先尝试连接串口
        await openSerialPort();
      }

      if (!writer)
      {
        return;
      }

      // 自动发送'w'指令获取IP地址
      await sendWifiCommand();
    }

    function closeWifiDialog()
    {
      const dialog = document.querySelector('.wifi-dialog');
      const overlay = document.querySelector('.overlay');
      if (dialog) dialog.remove();
      if (overlay) overlay.remove();
    }

    // 发送WiFi命令获取IP地址
    async function sendWifiCommand()
    {
      if (!writer)
      {
        return;
      }

      try
      {
        // 发送'w'指令获取IP地址
        const command = 'w\n';
        await writer.write(new TextEncoder().encode(command));
        console.log('Sent WiFi command to get IP address');

        // 等待一段时间让设备响应
        setTimeout(() =>
        {
          // 检查是否获取到了IP地址
          if (!currentDeviceIP)
          {
            // 如果没有获取到IP地址，显示WiFi配置界面
            showWifiConfigDialog();
          }
        }, 3000); // 等待3秒

      } catch (error)
      {
        console.error('Failed to send WiFi command:', error);
        // 发送失败时显示WiFi配置界面
        showWifiConfigDialog();
      }
    }

    // 显示WiFi配置对话框
    function showWifiConfigDialog()
    {
      // 创建遮罩层
      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      document.body.appendChild(overlay);

      // 创建对话框
      const dialog = document.createElement('div');
      dialog.className = 'wifi-dialog';
      dialog.innerHTML = `
        <h3>${getText("wifiConfig")}</h3>
        <input type="text" id="ssidInput" placeholder="${getText("ssidPlaceholder")}">
        <input type="password" id="passwordInput" placeholder="${getText("passwordPlaceholder")}">
        <div class="button-container">
          <button class="cancel" onclick="closeWifiDialog()">${getText("cancel")}</button>
          <button class="confirm" onclick="confirmWifiSettings()">${getText("confirm")}</button>
        </div>
      `;
      document.body.appendChild(dialog);
    }

    // 重置Quick Connect按钮样式和文本为默认状态
    function resetQuickConnectButton()
    {
      const quickConnectBtn = document.getElementById('quickConnectBtn');
      if (quickConnectBtn)
      {
        quickConnectBtn.textContent = getText("quickConnect");
        quickConnectBtn.style.backgroundColor = ''; // 恢复默认颜色
        quickConnectBtn.removeAttribute('data-connected'); // 移除连接状态标记
      }
    }

    async function confirmWifiSettings()
    {
      const ssid = document.getElementById('ssidInput').value.trim();
      const password = document.getElementById('passwordInput').value.trim();

      if (!ssid)
      {
        alert(getText("enterWifiName"));
        return;
      }

      const command = `w%${ssid}%${password}\n`;

      try
      {
        await writer.write(new TextEncoder().encode(command));
        closeWifiDialog();

        // 确保按钮状态正确 - Wifi配置可能意味着连接已建立
        if (!document.getElementById('closeSerialBtn').style.display ||
          document.getElementById('closeSerialBtn').style.display === 'none')
        {
          // 如果关闭按钮不可见，则现在应该显示
          document.getElementById('openSerialBtn').style.display = 'none';
          document.getElementById('closeSerialBtn').style.display = 'inline-flex';
        }
      } catch (error)
      {
        console.error(getText("wifiCommandError"), error);
        alert(getText("wifiCommandFailed"));
        // 连接失败时重置按钮
        resetQuickConnectButton();
      }
    }

    async function readSerialData()
    {
      try
      {
        while (true)
        {
          const { value, done } = await reader.read();
          if (done)
          {
            reader.releaseLock();
            break;
          }
          const text = new TextDecoder().decode(value);
          if (!text) continue; // 如果没有数据，跳过
          serialBufferText += text;
          const lastLineIndex = serialBufferText.lastIndexOf('\r\n');
          const linesText = serialBufferText.substring(0, lastLineIndex) + '\r\n';
          const lines = linesText.split('\r\n');
          serialBufferText = serialBufferText.substring(lastLineIndex + 2); // 保留剩余部分
          serialBuffer += text; // 添加到serialBuffer

          // 监听特定格式的输出：类似 "=\r\n4894\r\nR\r\n" 的格式
          // 检查是否包含 "=\r\n" 开头和 "\r\nR\r\n" 结尾的模式
          const patternMatch = linesText.match(/=\r\n([^\r\n]+)\r\n[a-zA-Z]{1}\r\n/);
          if (patternMatch)
          {
            // 提取第二行内容（第一行是"="，第二行是数字，第三行是"R"）
            const secondLine = patternMatch[1];
            addConsoleMessage(secondLine);
          }

          // 如果console缓冲区过大，防止内存泄漏
          if (serialBuffer.length > 10000)
          {
            serialBuffer = serialBuffer.substring(serialBuffer.length - 5000);
          }

          for (let line of lines.reverse())
          {
            // 检查是否找到"IP Address:"字符串
            const ipAddressPosition = line.indexOf("IP Address:");
            const afterPrefix = line.substring(ipAddressPosition).trim();
            const possibleIPMatch = afterPrefix.match(/^IP Address:\s*(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/);
            if (possibleIPMatch)
            {
              // 取消任何正在进行的IP检查定时器
              if (ipCheckTimer)
              {
                clearTimeout(ipCheckTimer);
                ipCheckTimer = null;
              }

              const possibleIP = possibleIPMatch[1];
              // 延迟处理IP地址，等待可能的后续数据片段
              lastPartialIP = possibleIP;

              // 设置延迟处理定时器 (100ms)
              ipCheckTimer = setTimeout(() =>
              {
                processDetectedIP(lastPartialIP);
                ipCheckTimer = null;
                lastPartialIP = null;
              }, 100);
              break; // 找到IP地址后跳出循环
            }
          }

          // 将数据添加到缓冲区
          serialOutputBuffer += text;

          // 检查缓冲区中是否包含换行符
          if (serialOutputBuffer.includes('\n'))
          {
            // 如果有换行符，立即处理到换行符为止的数据
            processSerialOutputBufferWithNewlines();
          } else
          {
            // 如果没有换行符，使用延时缓冲
            if (serialOutputTimer)
            {
              clearTimeout(serialOutputTimer);
            }
            serialOutputTimer = setTimeout(() =>
            {
              processSerialOutputBuffer();
            }, 30);
          }
        }
      } catch (error)
      {
        console.error(getText("serialReadError"), error);
      }
    }

    // 处理串口输出缓冲区（带换行符的智能处理）
    function processSerialOutputBufferWithNewlines()
    {
      if (!serialOutputBuffer.trim())
      {
        return;
      }

      const outputDiv = document.getElementById('serialOutput');
      const showSerialTimestamp = document.getElementById('showSerialTimestampBtn').classList.contains('active');
      const currentTime = Date.now();
      const timeSinceLastMessage = currentTime - lastSerialMessageTime;

      // 找到第一个换行符的位置
      const newlineIndex = serialOutputBuffer.indexOf('\n');
      if (newlineIndex === -1)
      {
        return; // 没有换行符，不应该调用这个函数
      }

      // 提取到换行符为止的完整消息
      const completeMessage = serialOutputBuffer.substring(0, newlineIndex + 1);
      // 保留剩余的数据
      serialOutputBuffer = serialOutputBuffer.substring(newlineIndex + 1);

      // 检查是否需要添加换行符（如果离上次收到消息超过100ms）
      const needNewLine = timeSinceLastMessage > 100;

      // 如果时间间隔超过100ms，添加换行符
      if (needNewLine)
      {
        outputDiv.appendChild(document.createElement('br'));
      }

      // 处理完整消息
      const lines = completeMessage.split('\n');
      let isFirstLine = true;

      lines.forEach((line, index) =>
      {
        // 跳过空行
        if (line.trim() === '' && index === lines.length - 1)
        {
          return;
        }

        // 检查是否需要添加timestamp
        let needTimestamp = false;
        if (isFirstLine)
        {
          // 第一行：总是添加timestamp（新消息的开始）
          needTimestamp = true;
          isFirstLine = false;
        } else
        {
          // 后续行：如果换行后要显示的是可显示字符，则加timestamp
          needTimestamp = line.trim().length > 0;
        }

        if (line.trim() !== '')
        {
          // 创建时间戳容器
          const timestampSpan = document.createElement('span');
          timestampSpan.className = 'timestamp';
          timestampSpan.textContent = needTimestamp ? `${getFormattedTimestamp()} ` : '';
          timestampSpan.style.display = (showSerialTimestamp && needTimestamp) ? 'inline' : 'none';
          timestampSpan.style.color = '#888';
          timestampSpan.style.fontWeight = 'normal';

          // 创建消息内容容器
          const messageSpan = document.createElement('span');
          messageSpan.className = 'message-content';
          messageSpan.textContent = line;
          messageSpan.style.color = '#fff';

          // 创建容器div
          const lineDiv = document.createElement('div');
          lineDiv.style.padding = '3px 0';
          lineDiv.style.marginBottom = '3px';
          lineDiv.style.fontSize = '13px';
          lineDiv.style.whiteSpace = 'nowrap';
          lineDiv.style.lineHeight = '1.3';

          // 将时间戳和消息添加到容器中
          lineDiv.appendChild(timestampSpan);
          lineDiv.appendChild(messageSpan);

          outputDiv.appendChild(lineDiv);

          // 每换行一次就重置时间，避免累积导致错误换行
          lastSerialMessageTime = currentTime;
        }
      });

      // 立即滚动到底部
      outputDiv.scrollTop = outputDiv.scrollHeight;
      // 强制DOM重绘
      void outputDiv.offsetHeight;

      // 如果缓冲区中还有数据，继续处理
      if (serialOutputBuffer.includes('\n'))
      {
        processSerialOutputBufferWithNewlines();
      }
    }

    // 处理串口输出缓冲区（延时处理）
    function processSerialOutputBuffer()
    {
      if (!serialOutputBuffer.trim())
      {
        return;
      }

      const outputDiv = document.getElementById('serialOutput');
      const showSerialTimestamp = document.getElementById('showSerialTimestampBtn').classList.contains('active');
      const currentTime = Date.now();
      const timeSinceLastMessage = currentTime - lastSerialMessageTime;

      // 检查是否需要添加换行符（如果离上次收到消息超过100ms）
      const needNewLine = timeSinceLastMessage > 100;

      // 如果时间间隔超过100ms，添加换行符
      if (needNewLine)
      {
        outputDiv.appendChild(document.createElement('br'));
      }

      // 处理文本内容，正确处理换行符
      const textLines = serialOutputBuffer.split('\n');
      let isFirstLine = true;

      textLines.forEach((line, index) =>
      {
        // 跳过空行
        if (line.trim() === '' && index === textLines.length - 1)
        {
          return;
        }

        // 检查是否需要添加timestamp
        let needTimestamp = false;
        if (isFirstLine)
        {
          // 第一行：总是添加timestamp（新消息的开始）
          needTimestamp = true;
          isFirstLine = false;
        } else
        {
          // 后续行：如果换行后要显示的是可显示字符，则加timestamp
          needTimestamp = line.trim().length > 0;
        }

        if (line.trim() !== '')
        {
          // 创建时间戳容器
          const timestampSpan = document.createElement('span');
          timestampSpan.className = 'timestamp';
          timestampSpan.textContent = needTimestamp ? `${getFormattedTimestamp()} ` : '';
          timestampSpan.style.display = (showSerialTimestamp && needTimestamp) ? 'inline' : 'none';
          timestampSpan.style.color = '#888';
          timestampSpan.style.fontWeight = 'normal';

          // 创建消息内容容器
          const messageSpan = document.createElement('span');
          messageSpan.className = 'message-content';
          messageSpan.textContent = line;
          messageSpan.style.color = '#fff';

          // 创建容器div
          const lineDiv = document.createElement('div');
          lineDiv.style.padding = '3px 0';
          lineDiv.style.marginBottom = '3px';
          lineDiv.style.fontSize = '13px';
          lineDiv.style.whiteSpace = 'nowrap';
          lineDiv.style.lineHeight = '1.3';

          // 将时间戳和消息添加到容器中
          lineDiv.appendChild(timestampSpan);
          lineDiv.appendChild(messageSpan);

          outputDiv.appendChild(lineDiv);

          // 每换行一次就重置时间，避免累积导致错误换行
          lastSerialMessageTime = currentTime;
        }
      });

      // 清空缓冲区
      serialOutputBuffer = '';

      // 立即滚动到底部
      outputDiv.scrollTop = outputDiv.scrollHeight;
      // 强制DOM重绘
      void outputDiv.offsetHeight;
    }

    // 处理检测到的IP地址
    async function processDetectedIP(ip)
    {
      if (!ip) return;

      // 验证IP地址格式是否合法
      const ipSegments = ip.split('.');
      if (ipSegments.length === 4 && ipSegments.every(segment =>
      {
        // 检查每段是否为有效数字且在0-255范围内
        const num = parseInt(segment, 10);
        return !isNaN(num) && num >= 0 && num <= 255;
      }))
      {
        // IP地址格式完整且合法，可以安全使用

        // 检查是否为新的IP地址
        if (currentDeviceIP !== ip)
        {
          console.log(getText("newIPDetected").replace("{ip}", ip).replace("{oldIP}", currentDeviceIP));

          // 保存设备IP到全局变量
          currentDeviceIP = ip;

          // 修改Quick Connect按钮样式和文本
          const quickConnectBtn = document.getElementById('quickConnectBtn');
          if (quickConnectBtn)
          {
            quickConnectBtn.textContent = ip;
            quickConnectBtn.style.backgroundColor = '#4CAF50'; // 绿色背景
            quickConnectBtn.setAttribute('data-connected', 'true'); // 标记连接状态
          }

          // 查找工作区中的make_connection积木块并更新IP地址
          const makeConnectionBlocks = workspace.getBlocksByType('make_connection');
          if (makeConnectionBlocks && makeConnectionBlocks.length > 0)
          {
            // 更新第一个make_connection积木块的IP_ADDRESS字段
            makeConnectionBlocks[0].setFieldValue(ip, 'IP_ADDRESS');
          }

          // 如果获取到IP地址，关闭可能存在的WiFi配置对话框
          closeWifiDialog();
        }
      } else
      {
        console.log(getText("invalidIPFormat").replace("{ip}", ip));
      }
    }

    async function sendSerialData()
    {
      if (!writer) return;

      const input = document.getElementById('serialInput');
      // 检查输入是否为空
      if (input.value.trim() === '') return;

      const data = input.value + '\n';

      try
      {
        await writer.write(new TextEncoder().encode(data));

        // 添加命令到历史记录
        if (input.value.trim() !== '')
        {
          // 避免重复添加相同的命令
          if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== input.value)
          {
            commandHistory.push(input.value);
          }
          // 保持历史记录在合理范围内(最多保存50条)
          if (commandHistory.length > 50)
          {
            commandHistory.shift();
          }
          // 重置历史索引
          historyIndex = -1;
          tempInputValue = '';
        }

        input.value = '';
      } catch (error)
      {
        console.error(getText("serialSendError"), error);
      }
    }

    function clearSerialOutput()
    {
      const outputDiv = document.getElementById('serialOutput');
      outputDiv.innerHTML = '';
      // 重置缓冲区
      serialBufferText = '';
      serialBuffer = '';
      serialOutputBuffer = '';
      // 重置时间变量
      lastSerialMessageTime = 0;
      // 清除定时器
      if (serialOutputTimer)
      {
        clearTimeout(serialOutputTimer);
        serialOutputTimer = null;
      }
    }

    // 添加回车键发送功能
    document.getElementById('serialInput').addEventListener('keypress', function (e)
    {
      if (e.key === 'Enter')
      {
        sendSerialData();
      }
    });

    // 添加上下箭头键历史命令功能
    document.getElementById('serialInput').addEventListener('keydown', function (e)
    {
      // 上箭头键
      if (e.key === 'ArrowUp')
      {
        e.preventDefault(); // 防止光标移到文本开头

        if (commandHistory.length > 0)
        {
          // 如果是第一次按上箭头，保存当前输入的内容
          if (historyIndex === -1)
          {
            tempInputValue = this.value;
          }

          // 向上浏览历史
          historyIndex = Math.min(historyIndex + 1, commandHistory.length - 1);
          this.value = commandHistory[commandHistory.length - 1 - historyIndex];
        }
      }
      // 下箭头键
      else if (e.key === 'ArrowDown')
      {
        e.preventDefault(); // 防止光标移到文本末尾

        if (historyIndex > 0)
        {
          // 向下浏览历史
          historyIndex--;
          this.value = commandHistory[commandHistory.length - 1 - historyIndex];
        }
        else if (historyIndex === 0)
        {
          // 回到临时保存的输入
          historyIndex = -1;
          this.value = tempInputValue;
        }
      }
    });

    // 添加撤销和重做按钮
    function addUndoRedoButtons()
    {
      // 检查是否已存在按钮，如果存在则移除
      const existingControls = document.querySelector('.undoRedoControls');
      if (existingControls)
      {
        existingControls.remove();
      }

      // 创建包含按钮的div
      const undoRedoControls = document.createElement('div');
      undoRedoControls.className = 'undoRedoControls';

      // 创建撤销按钮
      const undoButton = document.createElement('button');
      undoButton.className = 'undoRedoButton';
      undoButton.id = 'undoButton';
      undoButton.title = getText('undo');
      undoButton.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 14L4 9l5-5"/>
          <path d="M4 9h13c2.5 0 4 2 4 4s-1.5 4-4 4H8"/>
        </svg>
      `;
      undoButton.onclick = function ()
      {
        if (workspace.undoStack_ && workspace.undoStack_.length > 0)
        {
          workspace.undo(false);
          updateUndoRedoState();
        }
      };

      // 创建重做按钮
      const redoButton = document.createElement('button');
      redoButton.className = 'undoRedoButton';
      redoButton.id = 'redoButton';
      redoButton.title = getText('redo');
      redoButton.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M15 14l5-5-5-5"/>
          <path d="M20 9H7c-2.5 0-4 2-4 4s1.5 4 4 4h9"/>
        </svg>
      `;
      redoButton.onclick = function ()
      {
        if (workspace.redoStack_ && workspace.redoStack_.length > 0)
        {
          workspace.undo(true);
          updateUndoRedoState();
        }
      };

      // 将按钮添加到控件容器
      undoRedoControls.appendChild(undoButton);
      undoRedoControls.appendChild(redoButton);

      // 将控件容器添加到body
      document.body.appendChild(undoRedoControls);

      // 确保按钮是可见的
      undoRedoControls.style.display = 'flex';

      // 尝试初次定位按钮
      repositionUndoRedoButtons();

      // 再尝试几次定位，确保即使DOM渲染有延迟也能正确显示
      setTimeout(repositionUndoRedoButtons, 500);
      setTimeout(repositionUndoRedoButtons, 1000);

      // 初始化按钮状态
      updateUndoRedoState();
    }

    // 更新撤销和重做按钮状态
    function updateUndoRedoState()
    {
      const undoButton = document.getElementById('undoButton');
      const redoButton = document.getElementById('redoButton');

      if (undoButton && redoButton)
      {
        // 修复hasUndo和hasRedo方法调用，改用undoStack_和redoStack_属性判断
        const canUndo = workspace.undoStack_ && workspace.undoStack_.length > 0;
        const canRedo = workspace.redoStack_ && workspace.redoStack_.length > 0;

        undoButton.disabled = !canUndo;
        redoButton.disabled = !canRedo;

        // 更新按钮标题语言
        undoButton.title = getText('undo');
        redoButton.title = getText('redo');
      }
    }

    // 添加分隔线拖动功能
    document.addEventListener('DOMContentLoaded', function ()
    {
      // 获取所有需要的DOM元素
      const horizontalDivider = document.getElementById('console-serial-divider');
      const divider = document.getElementById('divider');
      const container = document.querySelector('.workspace-container');
      const blocklyDiv = document.getElementById('blocklyDiv');
      const windowsContainer = document.querySelector('.windows-container');
      const consoleWindow = document.getElementById('consoleWindow');
      const serialContainer = document.getElementById('serialContainer');

      // 确保分隔线初始隐藏
      if (horizontalDivider)
      {
        horizontalDivider.style.display = 'none';
      }

      // 设置初始的控制台和串口区域比例
      // 控制台占据大部分空间，串口区域只占据底部一小部分
      consoleWindow.style.flex = '90';
      serialContainer.style.flex = '10';

      let isResizing = false;
      let initialX, initialWidth;

      divider.addEventListener('mousedown', function (e)
      {
        // 启动调整大小
        isResizing = true;
        initialX = e.clientX;
        initialWidth = blocklyDiv.getBoundingClientRect().width;

        // 添加调整中的样式
        container.classList.add('resizing');
        divider.classList.add('active');

        // 阻止默认行为，确保拖动正常工作
        e.preventDefault();
      });

      document.addEventListener('mousemove', function (e)
      {
        if (!isResizing) return;

        // 计算移动距离
        const deltaX = e.clientX - initialX;

        // 计算容器总宽度
        const containerWidth = container.getBoundingClientRect().width;

        // 计算新的blocklyDiv宽度 (百分比)
        let newWidthPercent = ((initialWidth + deltaX) / containerWidth) * 100;

        // 确保合理范围 (20% - 80%)
        newWidthPercent = Math.max(20, Math.min(80, newWidthPercent));

        // 应用新宽度 - 同时设置flexBasis和width属性
        blocklyDiv.style.flexBasis = `${newWidthPercent}% `;
        blocklyDiv.style.width = `${newWidthPercent}% `;
        windowsContainer.style.flexBasis = `${99 - newWidthPercent}% `;
        windowsContainer.style.width = `${99 - newWidthPercent}% `;

        // 调整Blockly工作区大小以适应新尺寸
        if (workspace)
        {
          Blockly.svgResize(workspace);
        }

        // 更新undo/redo按钮位置
        repositionUndoRedoButtons();

        // 阻止默认行为
        e.preventDefault();
      });

      document.addEventListener('mouseup', function ()
      {
        if (isResizing)
        {
          // 停止调整大小
          isResizing = false;

          // 移除调整中的样式
          container.classList.remove('resizing');
          divider.classList.remove('active');

          // 确保Blockly工作区尺寸正确
          if (workspace)
          {
            Blockly.svgResize(workspace);
          }
        }

        // 同时处理垂直调整的停止
        if (isVerticalResizing)
        {
          // 停止垂直调整
          isVerticalResizing = false;

          // 移除调整中的样式
          horizontalDivider.classList.remove('active');
          document.body.style.cursor = '';
        }
      });

      // 添加垂直分隔线拖动功能
      let isVerticalResizing = false;
      let initialY, initialConsoleHeight;

      // 确保分隔线存在
      if (horizontalDivider)
      {
        horizontalDivider.addEventListener('mousedown', function (e)
        {
          // 启动垂直调整
          isVerticalResizing = true;
          initialY = e.clientY;
          initialConsoleHeight = consoleWindow.getBoundingClientRect().height;

          // 添加调整中的样式
          horizontalDivider.classList.add('active');
          document.body.style.cursor = 'row-resize';

          // 阻止事件冒泡和默认行为
          e.stopPropagation();
          e.preventDefault();
        });
      }

      // 扩展现有的mousemove事件处理程序，处理垂直调整
      document.addEventListener('mousemove', function (e)
      {
        // 处理垂直调整
        if (isVerticalResizing && horizontalDivider)
        {
          // 计算移动距离
          const deltaY = e.clientY - initialY;

          // 获取windows-container的总高度
          const containerHeight = windowsContainer.getBoundingClientRect().height;

          // 计算新的控制台高度百分比
          let newConsoleHeightPercent = ((initialConsoleHeight + deltaY) / containerHeight) * 100;

          // 确保合理范围 (20% - 80%)
          newConsoleHeightPercent = Math.max(20, Math.min(80, newConsoleHeightPercent));

          // 应用新高度比例
          consoleWindow.style.flex = `${newConsoleHeightPercent} `;
          serialContainer.style.flex = `${100 - newConsoleHeightPercent - 1}`;  // 减去分隔线高度

          // 更新undo/redo按钮位置
          repositionUndoRedoButtons();

          // 阻止事件继续传播和默认行为
          e.stopPropagation();
          e.preventDefault();
        }
      });
    });

  </script>
</body>

</html>
